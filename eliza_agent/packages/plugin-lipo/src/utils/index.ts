import nodemailer from "nodemailer";
import type { IAgentRuntime } from "@elizaos/core";

/**
 * Create email transporter using runtime settings
 */
export function createEmailTransporter(runtime: IAgentRuntime) {
    const emailUser = runtime.getSetting("EMAIL_OUTGOING_USER");
    const emailPass = runtime.getSetting("EMAIL_OUTGOING_PASS");
    
    if (!emailUser || !emailPass) {
        throw new Error("EMAIL_USER and EMAIL_APP_PASSWORD must be set in runtime settings");
    }
    
    return nodemailer.createTransport({
        service: "gmail",
        host: "smtp.gmail.com",
        auth: {
            user: emailUser,
            pass: emailPass
        },
        secure: true,
        port: 465
    });
}

/**
 * Send email using runtime settings
 */
export async function sendEmail(
    runtime: IAgentRuntime,
    options: {
        to: string;
        subject: string;
        html?: string;
        text?: string;
        from?: string;
    }
) {
    const transporter = createEmailTransporter(runtime);
    const emailUser = runtime.getSetting("EMAIL_USER");
    
    const mailOptions = {
        from: options.from || emailUser,
        to: options.to,
        subject: options.subject,
        html: options.html,
        text: options.text
    };
    
    try {
        const info = await transporter.sendMail(mailOptions);
        console.log("Email sent successfully:", info.messageId);
        return { success: true, messageId: info.messageId };
    } catch (error) {
        console.error("Failed to send email:", error);
        throw new Error(`Email sending failed: ${error.message}`);
    }
}

/**
 * Send volatility prediction email
 */
export async function sendVolatilityEmail(
    runtime: IAgentRuntime,
    prediction: any,
    recipientEmail?: string
) {
    const defaultRecipient = runtime.getSetting("EMAIL_RECIPIENT") || runtime.getSetting("EMAIL_USER");
    const recipient = recipientEmail || defaultRecipient;
    
    if (!recipient) {
        throw new Error("No recipient email specified");
    }
    
    const { prediction: pred } = prediction;
    
    const htmlContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #2563eb;">üìà Volatility Analysis Report</h2>
            
            <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #1e40af; margin-top: 0;">üéØ Key Metrics for ${pred.trading_pair}</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="margin: 10px 0;"><strong>Annualized Volatility:</strong> ${pred.annualized_volatility.toFixed(2)}%</li>
                    <li style="margin: 10px 0;"><strong>5-Day Predicted Volatility:</strong> ${pred.predicted_volatility_5d.toFixed(2)}%</li>
                    <li style="margin: 10px 0;"><strong>Risk Level:</strong> ${pred.volatility_level}</li>
                </ul>
            </div>
            
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #475569; margin-top: 0;">üìä Technical Features</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="margin: 10px 0;"><strong>Realized Volatility:</strong> ${pred.features.realized_vol.toFixed(4)}</li>
                    <li style="margin: 10px 0;"><strong>Returns Squared:</strong> ${pred.features.returns_squared.toFixed(4)}</li>
                </ul>
            </div>
            
            <div style="background: #ecfdf5; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #059669; margin-top: 0;">üìÖ Analysis Details</h3>
                <p><strong>Analysis Date:</strong> ${new Date(pred.timestamp).toLocaleString()}</p>
                <p><strong>Data Source:</strong> ${pred.data_source}</p>
            </div>
            
            <div style="border-left: 4px solid #3b82f6; padding-left: 16px; margin: 20px 0;">
                <p style="color: #1e40af; font-style: italic;">
                    This automated report was generated by your AI trading assistant.
                </p>
            </div>
        </div>
    `;
    
    await sendEmail(runtime, {
        to: recipient,
        subject: `Volatility Analysis: ${pred.trading_pair} - ${pred.volatility_level} Risk`,
        html: htmlContent
    });
}


/**
 * Send rebalance report email
 */
export async function sendRebalanceEmail(
    runtime: IAgentRuntime,
    rebalanceResult: any,
    rebalanceRequest: any,
    prediction: any,
    recipientEmail?: string
) {
    const defaultRecipient = runtime.getSetting("EMAIL_RECIPIENT") || runtime.getSetting("EMAIL_USER");
    const recipient = recipientEmail || defaultRecipient;
    
    if (!recipient) {
        throw new Error("No recipient email specified");
    }
    
    const { prediction: pred } = prediction;
    const result = rebalanceResult;
    
    // Determine status colors and icons
    const statusColor = result.success ? "#059669" : "#dc2626";
    const statusIcon = result.success ? "‚úÖ" : "‚ùå";
    const statusText = result.success ? "SUCCESS" : "FAILED";
    
    // Format transaction hash with etherscan link
    const txHash = result.newPositionTx?.hash;
    const etherscanLink = txHash ? 
        `<a href="https://sepolia.etherscan.io/tx/${txHash}" style="color: #2563eb; text-decoration: none;">${txHash.slice(0, 10)}...${txHash.slice(-8)}</a>` : 
        "N/A";
    
    // Format amounts
    const formatAmount = (amount: bigint, decimals: number, symbol: string) => {
        if (!amount || amount === BigInt(0)) return "0";
        const formatted = Number(amount) / Number(BigInt(10) ** BigInt(decimals));
        return `${formatted.toFixed(6)} ${symbol}`;
    };
    
    const htmlContent = `
        <div style="font-family: Arial, sans-serif; max-width: 700px; margin: 0 auto; background: #ffffff;">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px 20px; text-align: center; border-radius: 8px 8px 0 0;">
                <h1 style="margin: 0; font-size: 28px;">üîÑ Liquidity Position Rebalance Report</h1>
                <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 16px;">${new Date().toLocaleString()}</p>
            </div>
            
            <!-- Status Banner -->
            <div style="background: ${statusColor}; color: white; padding: 15px 20px; text-align: center;">
                <h2 style="margin: 0; font-size: 20px;">${statusIcon} REBALANCE ${statusText}</h2>
            </div>
            
            <!-- Main Content -->
            <div style="padding: 20px;">
                
                <!-- Rebalance Summary -->
                <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                    <h3 style="color: #1e40af; margin-top: 0;">üìä Rebalance Summary</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <p style="margin: 5px 0;"><strong>Trading Pair:</strong> ${pred.trading_pair}</p>
                            <p style="margin: 5px 0;"><strong>Action Taken:</strong> ${rebalanceRequest.rebalanceAction}</p>
                            <p style="margin: 5px 0;"><strong>Volatility Threshold:</strong> ${rebalanceRequest.volatilityThreshold}</p>
                        </div>
                        <div>
                            <p style="margin: 5px 0;"><strong>Current Volatility:</strong> ${pred.predicted_volatility_5d.toFixed(2)}%</p>
                            <p style="margin: 5px 0;"><strong>Risk Level:</strong> ${pred.volatility_level}</p>
                            <p style="margin: 5px 0;"><strong>Positions Closed:</strong> ${result.closedPositions?.length || 0}</p>
                        </div>
                    </div>
                </div>
                
                ${result.success ? `
                <!-- Position Details -->
                <div style="background: #ecfdf5; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #059669;">
                    <h3 style="color: #059669; margin-top: 0;">üí∞ New Position Details</h3>
                    <div style="background: white; padding: 15px; border-radius: 6px; margin: 10px 0;">
                        <p style="margin: 5px 0;"><strong>Tick Range:</strong> ${result.tickRange?.[0]} to ${result.tickRange?.[1]}</p>
                        <p style="margin: 5px 0;"><strong>Transaction:</strong> ${etherscanLink}</p>
                        <p style="margin: 5px 0;"><strong>Gas Used:</strong> View on Etherscan</p>
                    </div>
                </div>
                
                <!-- Closed Positions -->
                ${result.closedPositions?.length > 0 ? `
                <div style="background: #fef3c7; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #f59e0b;">
                    <h3 style="color: #d97706; margin-top: 0;">üîÑ Closed Positions</h3>
                    <ul style="list-style: none; padding: 0;">
                        ${result.closedPositions.map((id: bigint) => 
                            `<li style="background: white; padding: 10px; margin: 5px 0; border-radius: 4px;">
                                Position NFT ID: ${id.toString()}
                            </li>`
                        ).join('')}
                    </ul>
                </div>
                ` : ''}
                ` : `
                <!-- Error Details -->
                <div style="background: #fef2f2; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #dc2626;">
                    <h3 style="color: #dc2626; margin-top: 0;">üö´ Error Details</h3>
                    <p style="background: white; padding: 15px; border-radius: 6px; margin: 10px 0; font-family: monospace; word-break: break-all;">
                        ${result.message}
                    </p>
                </div>
                `}
                
                <!-- Volatility Analysis -->
                <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #6366f1;">
                    <h3 style="color: #4f46e5; margin-top: 0;">üìà Volatility Context</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: white; padding: 15px; border-radius: 6px;">
                            <h4 style="margin: 0 0 10px 0; color: #374151;">Predicted Metrics</h4>
                            <p style="margin: 5px 0;"><strong>5-Day Volatility:</strong> ${pred.predicted_volatility_5d.toFixed(2)}%</p>
                            <p style="margin: 5px 0;"><strong>Annualized Volatility:</strong> ${pred.annualized_volatility.toFixed(2)}%</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 6px;">
                            <h4 style="margin: 0 0 10px 0; color: #374151;">Technical Features</h4>
                            <p style="margin: 5px 0;"><strong>Realized Vol:</strong> ${pred.features.realized_vol.toFixed(4)}</p>
                            <p style="margin: 5px 0;"><strong>Returns¬≤:</strong> ${pred.features.returns_squared.toFixed(4)}</p>
                        </div>
                    </div>
                </div>
                
                <!-- Strategy Explanation -->
                <div style="background: #e0f2fe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #0284c7;">
                    <h3 style="color: #0369a1; margin-top: 0;">üí° Strategy Rationale</h3>
                    <p style="line-height: 1.6; margin: 0;">
                        ${getStrategyExplanation(rebalanceRequest.rebalanceAction, pred.predicted_volatility_5d, pred.volatility_level)}
                    </p>
                </div>
                
                <!-- Risk Management -->
                <div style="background: #fff7ed; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #ea580c;">
                    <h3 style="color: #c2410c; margin-top: 0;">‚ö†Ô∏è Risk Considerations</h3>
                    <ul style="line-height: 1.6; margin: 10px 0; padding-left: 20px;">
                        <li>Current volatility is ${pred.predicted_volatility_5d > 10 ? 'HIGH' : pred.predicted_volatility_5d > 5 ? 'MODERATE' : 'LOW'} - monitor position closely</li>
                        <li>Concentrated liquidity positions can experience impermanent loss</li>
                        <li>Consider rebalancing if market conditions change significantly</li>
                        ${pred.predicted_volatility_5d > 15 ? '<li style="color: #dc2626;"><strong>HIGH VOLATILITY WARNING:</strong> Position may go out of range quickly</li>' : ''}
                    </ul>
                </div>
                
            </div>
            
            <!-- Footer -->
            <div style="background: #f9fafb; padding: 20px; text-align: center; border-radius: 0 0 8px 8px; border-top: 1px solid #e5e7eb;">
                <p style="margin: 0; color: #6b7280; font-size: 14px;">
                    ü§ñ This automated report was generated by your AI DeFi Assistant<br>
                    <strong>Data Source:</strong> ${pred.data_source} | <strong>Analysis Time:</strong> ${new Date(pred.timestamp).toLocaleString()}
                </p>
            </div>
        </div>
    `;
    
    const subject = result.success ? 
        `‚úÖ Rebalance Complete: ${pred.trading_pair} - ${rebalanceRequest.rebalanceAction}` :
        `‚ùå Rebalance Failed: ${pred.trading_pair} - ${result.message}`;
    
    await sendEmail(runtime, {
        to: recipient,
        subject: subject,
        html: htmlContent
    });
}

// For backward compatibility - export the function to create transporter
export const getTransporter = createEmailTransporter;

const MIN_TICK = -887272;
const MAX_TICK = -MIN_TICK;
const TICKS_Q = 1.0001;
const Q96 = 2n ** 96n;
const MAX_UINT_128 = 2n ** 128n - 1n;

// Fee tier to tick spacing mapping
const TICK_SPACING: Record<number, number> = {
  100: 1,
  500: 10,
  3000: 60,
  10000: 200,
};

// Type definitions
type FeeTier = 100 | 500 | 3000 | 10000;
type TickRange = [number, number];

/**
 * Convert price to tick
 */
function priceToTick(price: number): number {
  // Make sure we're working with regular numbers
  const priceNum = Number(price);
  const q96Num = Number(Q96);
  
  const sqrtPriceX96 = Math.floor(priceNum * q96Num);
  const tick = Math.floor(Math.log((sqrtPriceX96 / q96Num) ** 2) / Math.log(TICKS_Q));
  return tick;
}
/**
 * Convert tick to price
 */
function tickToPrice(
  tick: number, 
  decimals0: number, 
  decimals1: number, 
  invert: boolean = false
): number {
  // Ensure all inputs are regular numbers
  const tickNum = Number(tick);
  const dec0 = Number(decimals0);
  const dec1 = Number(decimals1);
  
  const price = TICKS_Q ** tickNum / (10 ** (dec1 - dec0));
  
  return invert ? 1 / price : price;
}

/**
 * Get minimum valid tick for fee tier
 */
function getMinTick(fee: FeeTier): number {
  const minTickSpacing = TICK_SPACING[fee];
  if (!minTickSpacing) {
    throw new Error(`Invalid fee tier: ${fee}`);
  }
  return -Math.floor(-MIN_TICK / minTickSpacing) * minTickSpacing;
}

/**
 * Get maximum valid tick for fee tier
 */
function getMaxTick(fee: FeeTier): number {
  const maxTickSpacing = TICK_SPACING[fee];
  if (!maxTickSpacing) {
    throw new Error(`Invalid fee tier: ${fee}`);
  }
  return Math.floor(MAX_TICK / maxTickSpacing) * maxTickSpacing;
}

/**
 * Get default tick range for fee tier
 */
function defaultTickRange(fee: FeeTier): TickRange {
  const minTick = getMinTick(fee);
  const maxTick = getMaxTick(fee);
  return [minTick, maxTick];
}

/**
 * Round tick to nearest valid tick for fee tier
 */
function nearestTick(tick: number, fee: FeeTier): number {
  const [minTick, maxTick] = defaultTickRange(fee);
  
  if (tick < minTick || tick > maxTick) {
    throw new Error(`Provided tick ${tick} is out of bounds: [${minTick}, ${maxTick}]`);
  }
  
  const tickSpacing = TICK_SPACING[fee];
  if (!tickSpacing) {
    throw new Error(`Invalid fee tier: ${fee}`);
  }
  
  let roundedTickSpacing = Math.round(tick / tickSpacing) * tickSpacing;
  
  if (roundedTickSpacing < minTick) {
    return roundedTickSpacing + tickSpacing;
  } else if (roundedTickSpacing > maxTick) {
    return roundedTickSpacing - tickSpacing;
  } else {
    return roundedTickSpacing;
  }
}

/**
 * Get tick range around current price with percentage deviation
 */
function getTickRange(
  currTick: number,
  pctDev: number,
  tokenADecimals: number,
  tokenBDecimals: number,
  fee: FeeTier
): TickRange {
  const currPrice = tickToPrice(currTick, tokenADecimals, tokenBDecimals);
  const upperPrice = currPrice * (1 + pctDev);
  const lowerPrice = currPrice * (1 - pctDev);
  
  const lowerTick = priceToTick(lowerPrice);
  const upperTick = priceToTick(upperPrice);
  
  const adjustedLowerTick = nearestTick(lowerTick, fee);
  const adjustedUpperTick = nearestTick(upperTick, fee);
  
  return [adjustedLowerTick, adjustedUpperTick];
}

/**
 * Get strategy explanation based on action and volatility
 */
function getStrategyExplanation(action: string, volatility: number, riskLevel: string): string {
    switch (action.toLowerCase()) {
        case 'auto_optimize':
            if (volatility > 15) {
                return `With ${volatility.toFixed(1)}% predicted volatility (${riskLevel}), the system automatically reduced position size to minimize risk while maintaining exposure to potential gains.`;
            } else if (volatility < 5) {
                return `Low volatility environment (${volatility.toFixed(1)}%) detected. Position size was increased to maximize capital efficiency in stable market conditions.`;
            } else {
                return `Moderate volatility (${volatility.toFixed(1)}%) suggests maintaining balanced exposure. Position was optimized for current market conditions.`;
            }
        
        case 'reduce_exposure':
            return `Position exposure was deliberately reduced due to ${riskLevel.toLowerCase()} volatility (${volatility.toFixed(1)}%). This defensive strategy helps protect capital during uncertain market conditions.`;
        
        case 'increase_exposure':
            return `Position size was increased to capitalize on current market conditions. With ${volatility.toFixed(1)}% volatility, this aggressive strategy aims to maximize returns.`;
        
        case 'exit_position':
            return `All positions were closed due to ${riskLevel.toLowerCase()} volatility conditions (${volatility.toFixed(1)}%). This risk-off approach preserves capital until market conditions stabilize.`;
        
        default:
            return `Position was rebalanced based on current volatility of ${volatility.toFixed(1)}% and ${riskLevel.toLowerCase()} risk assessment.`;
    }
}

// Export all functions and types
export {
  priceToTick,
  tickToPrice,
  getMinTick,
  getMaxTick,
  defaultTickRange,
  nearestTick,
  getTickRange,
  MIN_TICK,
  MAX_TICK,
  TICKS_Q,
  Q96,
  MAX_UINT_128,
  TICK_SPACING,
  type FeeTier,
  type TickRange,
};


// Prediction types
type PredictionRequest = {
    tokenPair: string;
    days: number;
    includeSentiment: boolean;
    analysisType: string;
};

type PredictionResponse = {
    message: string;
    prediction: {
        annualized_volatility: number;
        data_source: string;
        features: {
            realized_vol: number;
            returns_squared: number;
        };
        predicted_volatility_5d: number;
        timestamp: string;
        trading_pair: string;
        volatility_level: string;
    };
    success: boolean;
};

export class VolatilityPredictionAction {
    private predictionApiUrl = "http://13.51.85.232:8000/predict";
    
    constructor() {}
    
    // Method to handle volatility predictions
    async fetchVolatilityPrediction(tokenPair: string, days: number): Promise<PredictionResponse> {
        try {
            const url = `${this.predictionApiUrl}?days=${days}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`Prediction API request failed with status ${response.status}`);
            }
            
            const data: PredictionResponse = await response.json();
            return data;
        } catch (error) {
            console.error("Error fetching volatility prediction:", error);
            throw new Error(`Failed to fetch volatility prediction: ${error.message}`);
        }
    }

    // Method to validate and normalize token pair
    validateTokenPair(tokenPair: string): string {
        const supportedPairs = ["LINKUSDT", "UNIUSDT", "AAVEUSDT", "SUSHIUSDT", "1INCHUSDT"];
        const normalizedPair = tokenPair?.toUpperCase();
        
        if (!supportedPairs.includes(normalizedPair)) {
            return "LINKUSDT"; // Default fallback
        }
        
        return normalizedPair;
    }

    // Method to format volatility level for display
    formatVolatilityLevel(level: string): string {
        switch (level.toUpperCase()) {
            case 'LOW':
                return 'üü¢ Low Risk';
            case 'MODERATE':
                return 'üü° Moderate Risk';
            case 'HIGH':
                return 'üî¥ High Risk';
            default:
                return `üìä ${level}`;
        }
    }

    // Method to format prediction response for display
    formatPredictionResponse(prediction: PredictionResponse): string {
        const { prediction: pred } = prediction;

        
        
        return `üìà **Volatility Analysis for ${pred.trading_pair}**
        
üéØ **Key Metrics:**
‚Ä¢ Annualized Volatility: ${pred.annualized_volatility.toFixed(2)}%
‚Ä¢ 5-Day Predicted Volatility: ${pred.predicted_volatility_5d.toFixed(2)}%
‚Ä¢ Risk Level: ${this.formatVolatilityLevel(pred.volatility_level)}

üìä **Technical Features:**
‚Ä¢ Realized Volatility: ${pred.features.realized_vol.toFixed(4)}
‚Ä¢ Returns Squared: ${pred.features.returns_squared.toFixed(4)}

üìÖ **Analysis Date:** ${new Date(pred.timestamp).toLocaleString()}
üîç **Data Source:** ${pred.data_source}

üí° **Risk Assessment:** ${this.getVolatilityInsight(pred.volatility_level, pred.annualized_volatility)}`;
    }

    // Method to provide volatility insights
    getVolatilityInsight(level: string, annualizedVol: number): string {
        switch (level.toUpperCase()) {
            case 'LOW':
                return "This asset shows relatively stable price movements, suitable for conservative strategies.";
            case 'MODERATE':
                return "Balanced risk-reward profile with moderate price fluctuations expected.";
            case 'HIGH':
                return "High volatility detected - consider risk management strategies and position sizing.";
            default:
                return `Current volatility of ${annualizedVol.toFixed(1)}% suggests careful position management.`;
        }
    }
}